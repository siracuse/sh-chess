{% extends 'base.html.twig' %}

{% block body %}
<h2>Thème tactique : {{ theme.name | capitalize }}</h2>
<div class="d-flex j-content-center g-20">
    <div id="myBoard" style="width: 400px"></div>
    <div class="grid2">
        <p id="gameStatus"></p>
        <p>Puzzle n°<span id="puzzleIndex">1</span></p>
        <p>Erreurs : <span id="errorCount">0</span></p>
        <p>⏱️ Temps écoulé : <span id="timer">00:00</span></p>
        <div id="feedbackZone" style="margin-top: 15px; font-size: 1.2em;"></div>
    </div>
</div>

<script>
let currentPuzzleId = {{ puzzle.id }};
let currentPuzzleIndex = 1;
let totalPuzzles = {{ totalPuzzles|default(0) }};
let errorCount = 0;

let initialFen = '{{ puzzle.fen }}';
let game = new Chess(initialFen);
let board = Chessboard2('myBoard', { draggable: true, position: initialFen, onDrop: onDrop, showNotation: true });
let solutionMoves = {{ solutionMove|json_encode|raw }};



let currentMoveIndex = 0;
let isLocked = false;

let timerInterval;
let totalSeconds = 0;

function startTimer() {
    timerInterval = setInterval(() => {
        totalSeconds++;
        const minutes = String(Math.floor(totalSeconds / 60)).padStart(2, '0');
        const seconds = String(totalSeconds % 60).padStart(2, '0');
        document.getElementById('timer').innerText = `${minutes}:${seconds}`;
    }, 1000);
}

function stopTimer() {
    clearInterval(timerInterval);
}

startTimer();
updateStatus();

function onDrop(dropEvt) {
    if (isLocked) return 'snapback';

    const move = game.move({ from: dropEvt.source, to: dropEvt.target, promotion: 'q' });
    if (!move) return 'snapback';

    const playedMove = dropEvt.source + dropEvt.target;

    if (playedMove === solutionMoves[currentMoveIndex]) {
        currentMoveIndex++;
        board.position(game.fen());
        updateStatus();

        if (currentMoveIndex >= solutionMoves.length) {
            checkIfLastPuzzle();
            isLocked = true;
            return;
        }

        if (currentMoveIndex === 1) {
            const autoMove = solutionMoves[currentMoveIndex];
            setTimeout(() => {
                game.move({ from: autoMove.slice(0,2), to: autoMove.slice(2,4), promotion:'q' });
                currentMoveIndex++;
                board.position(game.fen());
                updateStatus();
            }, 400);
        }

    } else {
        game.undo();
        errorCount++;
        document.getElementById('errorCount').innerText = errorCount;
        showFeedback(false);
        isLocked = true;
        return 'snapback';
    }
}

function showFeedback(success, isLast = false) {
    const feedbackZone = document.getElementById('feedbackZone');
    feedbackZone.innerHTML = '';

    const icon = document.createElement('span');
    icon.style.fontSize = '2em';
    icon.style.marginRight = '10px';

    const button = document.createElement('button');
    button.style.padding = '6px 12px';
    button.style.borderRadius = '8px';
    button.style.border = 'none';
    button.style.cursor = 'pointer';
    button.style.fontWeight = 'bold';

    if (success) {
        icon.textContent = '✅';
        icon.style.color = 'green';

        if (isLast) {
            stopTimer();
            const finalTime = document.getElementById('timer').innerText;
            feedbackZone.innerHTML = `
                <p> <b>Tous les puzzles terminés !</b><br>
                 Temps total : ${finalTime}<br>
                  Total d'erreur(s) : ${errorCount}</p>
            `;

            saveStats({ 
                themeId: {{ theme.id }}, 
                totalTime: totalSeconds,
                errors: errorCount 
            });

            return;
        }

        button.textContent = 'Puzzle suivant →';
        button.style.backgroundColor = '#4CAF50';
        button.style.color = 'white';
        button.onclick = () => {
            feedbackZone.innerHTML = '';
            onPuzzleComplete();
        };
    } else {
        icon.textContent = '❌';
        icon.style.color = 'red';
        button.textContent = '↻ Réessayer';
        button.style.backgroundColor = '#f44336';
        button.style.color = 'white';
        button.onclick = () => {
            feedbackZone.innerHTML = '';
            restartCurrentPuzzle();
        };
    }

    feedbackZone.appendChild(icon);
    feedbackZone.appendChild(button);
}

function saveStats(stats) {
    const formData = new FormData();
    formData.append('themeId', stats.themeId);
    formData.append('totalTime', stats.totalTime);
    formData.append('errors', stats.errors);

    fetch('{{ path("woodpecker_save_stats") }}', {
        method: 'POST',
        body: formData
    })
    .then(resp => resp.json())
    .then(data => {
        if (data.success) {
            console.log("Stats enregistrées !");
        } else {
            console.warn("Erreur lors de l'enregistrement des stats");
        }
    })
    .catch(err => console.error("Erreur réseau ou JSON:", err));
}

function restartCurrentPuzzle() {
    game = new Chess(initialFen);
    board.position(initialFen);
    currentMoveIndex = 0;
    isLocked = false;
    updateStatus();
}

function updateStatus() {
    document.getElementById('gameStatus').innerText =
        game.turn() === 'w' ? 'Trait aux Blancs' : 'Trait aux Noirs';
}

function checkIfLastPuzzle() {
    if (typeof totalPuzzles !== 'undefined' && totalPuzzles > 0) {
        if (currentPuzzleIndex >= totalPuzzles) {
            showFeedback(true, true); 
            return;
        }
    }

    const formData = new FormData();
    formData.append('currentId', currentPuzzleId);
    formData.append('themeId', {{ theme.id }});

    fetch('{{ path("woodpecker_next") }}', { method: 'POST', body: formData })
        .then(resp => resp.json())
        .then(data => {
            if (data.done) {
                showFeedback(true, true); 
            } else {
                window._nextPuzzleData = data;
                showFeedback(true, false);
            }
        });
}

function onPuzzleComplete() {
    const data = window._nextPuzzleData;
    if (!data) return;

    currentPuzzleId = data.id;
    currentPuzzleIndex++;
    solutionMoves = data.solution;
    currentMoveIndex = 0;
    initialFen = data.fen;
    game = new Chess(initialFen);
    board.position(initialFen);
    document.getElementById('puzzleIndex').innerText = currentPuzzleIndex;
    isLocked = false;
    updateStatus();
}

</script>
{% endblock %}
